# https://www.sqlite.org/lang.html

root = statement_or_query semicolon? eof;
statement_or_query =
  | SELECT => select
  | VALUES => values
  | CREATE => create
  | INSERT => insert;
create =
  | (CREATE TABLE) => create_table;
create_table = CREATE TABLE name open_paren column_specs close_paren;
insert = INSERT INTO name open_paren column_specs close_paren table_expr;
table_expr = 
  | VALUES => values;
values = VALUES open_paren exprs close_paren;
column_specs = column_spec*comma;
column_spec = name typ?;
typ = name;
select = SELECT distinct_or_all? result_columns from? where? group_by? having? window? order_by? limit?;
distinct_or_all =
  | DISTINCT
  | ALL;
result_columns = result_column*comma;
result_column = expr; # TODO
from = FROM tables_or_subqueries_or_join*;
tables_or_subqueries_or_join =
  | tables_or_subqueries
  | join_clause;
tables_or_subqueries = table_or_subquery+comma;
table_or_subquery = 
  | table
  | subquery;
table = name binding?; # TODO
binding = AS name;
join_clause = TODO;
where = WHERE expr;
group_by = GROUP BY exprs;
having = HAVING expr;
window = WINDOW TODO;
order_by = ORDER BY ordering_terms;
ordering_terms = ordering_term+comma;
ordering_term = collate? asc_or_desc? nulls_first_or_last? expr;
collate = COLLATE collation_name;
collation_name = name; # TODO
asc_or_desc =
  | ASC
  | DESC;
nulls_first_or_last = NULLS first_or_last;
first_or_last = 
  | FIRST
  | LAST;
limit = LIMIT exprs; # TODO offset
exprs = expr*comma;

expr = expr_or;
expr_or = expr_and=left ((OR expr_or)?)=right;
expr_and = expr_not=left ((AND expr_and)?)=right;
expr_not = NOT* expr_incomp;
expr_incomp = expr_comp=left ((op_incomp=op expr_incomp)?)=right;
expr_comp = expr_add=left ((op_comp=op expr_comp)?)=right;
expr_add = expr_mult=left ((op_add=op expr_add)?)=right;
expr_mult = expr_atom=left ((op_mult=op expr_atom)?)=right;

op_incomp = | equal | double_equal | not_equal; # | IS | IS_NOT | IS_DISTINCT_FROM | IS_NOT_DISTINCT_FROM;
op_comp = | less_than | greater_than | less_than_or_equal | greater_than_or_equal;
op_add = | plus | minus;
op_mult = | star | forward_slash | percent;

expr_atom =
  | CASE => case
  | subquery_prefix => subquery
  | open_paren => subexpr
  | function_call
  | table_column_ref
  | column_ref
  | value;

expr_incomp_complex = 
  | expr_incomp_between
  | expr_incomp_not_binop;
expr_incomp_between = expr_comp=left NOT? BETWEEN expr=start AND expr=end;
IS_NOT = IS NOT;
IS_DISTINCT_FROM = IS DISTINCT FROM;
IS_NOT_DISTINCT_FROM = IS NOT DISTINCT FROM;
expr_incomp_not_binop = expr_comp=left NOT? (| IN | MATCH | LIKE | REGEXP | GLOB)=op expr_incomp=right;
expr_incomp_postop = expr_comp=left (| ISNULL | NOTNULL | NOT_NULL)=op;
NOT_NULL = NOT NULL;

table_column_ref = name=table dot name=column;
column_ref = name;

subquery_prefix = exists_or_not_exists? open_paren SELECT;
subquery = exists_or_not_exists? open_paren select close_paren;
exists_or_not_exists =
  | EXISTS
  | NOT_EXISTS;
NOT_EXISTS = NOT EXISTS;

subexpr = open_paren expr close_paren;

case = CASE expr? case_when* case_else? END;
case_when = WHEN expr=when THEN expr=then;
case_else = ELSE expr;
function_call = function_name open_paren function_args? close_paren; # TODO filter/over
function_name = name; # TODO
function_args =
  | (DISTINCT? expr+comma)=args
  | star;
value =
  | number
  | string
  | NULL;