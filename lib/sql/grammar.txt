# https://www.sqlite.org/lang.html

root = statement_or_query semicolon? eof;
statement_or_query =
  | SELECT => select
  | VALUES => values
  | CREATE => create
  | INSERT => insert;
create =
  | (CREATE TABLE) => create_table;
create_table = CREATE TABLE name open_paren column_specs close_paren;
insert = INSERT INTO name open_paren column_specs close_paren table_expr;
table_expr = 
  | VALUES => values;
values = VALUES open_paren exprs close_paren;
column_specs = column_spec*comma;
column_spec = name typ?;
typ = name;
select = SELECT distinct_or_all? result_columns from? where? group_by? having? window? order_by? limit?;
distinct_or_all =
  | DISTINCT
  | ALL;
result_columns = result_column*comma;
result_column = expr; # TODO
from = FROM tables_or_subqueries_or_join*;
tables_or_subqueries_or_join =
  | tables_or_subqueries
  | join_clause;
tables_or_subqueries = table_or_subquery+comma;
table_or_subquery = 
  | table
  | subquery;
table = name binding?; # TODO
binding = AS name;
where = WHERE expr;
group_by = GROUP BY exprs;
having = HAVING expr;
window = WINDOW TODO;
order_by = ORDER BY ordering_terms;
ordering_terms = ordering_term+comma;
ordering_term = collate? asc_or_desc? null_first_or_last? expr;
collate = COLLATE collation_name;
collation_name = name; # TODO
asc_or_desc =
  | ASC
  | DESC;
nulls_first_or_last = NULLS first_or_last;
first_or_last = 
  | FIRST
  | LAST;
limit = LIMIT exprs; # TODO offset
exprs = expr*comma;
expr = expr_or_prec;

expr_or_prec =
  | expr_or
  | expr_and_prec;
expr_or = expr_and_prec=left OR expr_or_prec=right;

expr_and_prec =
  | expr_and
  | expr_not_prec;
expr_and = expr_not_prec=left AND expr_and_prec=right;

expr_not_prec =
  | expr_not
  | expr_incomp_prec;
expr_not = NOT expr_not_prec=right;

expr_incomp_prec =
  | expr_incomp
  | expr_comp_prec;
expr_incomp =
  | expr_incomp_binop
  | expr_incomp_complex
  | expr_incomp_postop;
expr_incomp_complex = 
  | expr_incomp_between
  | expr_incomp_not_binop;
expr_incomp_between = expr_comp_prec=left NOT? BETWEEN expr=start AND expr=end;
expr_income_binop = expr_comp_prec=left (| equal | double_equal | not_equal | IS | IS_NOT | IS_DISTINCT_FROM | IS_NOT_DISTINCT_FROM)=op expr_incomp_prec=right;
IS_NOT = IS NOT;
IS_DISTINCT_FROM = IS_DISTINCT_FROM;
IS_NOT_DISTINCT_FROM = IS_NOT_DISTINCT_FROM;
expr_income_not_binop = expr_comp_prec=left NOT? (| IN | MATCH | LIKE | REGEXP | GLOB)=op expr_incomp_prec=right;
expr_incomp_postop = expr_comp_prec=left (| ISNULL | NOTNULL | NOT_NULL)=op;
NOT_NULL = NOT NULL;

expr_comp_prec = 
  | expr_comp
  | expr_add_prec;
expr_comp = expr_add_prec=left (| less_than | greater_than | less_than_or_equal | greater_than_equal)=op expr_comp_prec=right;

expr_add_prec = 
  | expr_add
  | expr_mult_prec;
expr_add = expr_mult_prec=left (| plus | minus)=op expr_add_prec=right;

expr_mult_prec =
  | expr_mult
  | expr_atom;
expr_mult = expr_atom=left (| star | forward_slash | percent)=op expr_mult_prec=right;

expr_atom =
  | CASE => case
  | subquery
  | open_paren => subexpr
  | function_call
  | table_column_ref
  | column_ref
  | value;

table_column_ref = name=table dot name=column;
column_ref = name;

subquery_prefix = exists_or_not_exists? open_paren SELECT;
subquery = #exists_or_not_exists? 
open_paren select close_paren;
exists_or_not_exists =
  | EXISTS
  | NOT_EXISTS;
NOT_EXISTS = NOT EXISTS;

subexpr = open_paren expr close_paren;

case = CASE expr? case_when* case_else? END;
case_when = WHEN expr=when THEN expr=then;
case_else = ELSE expr;
function_call = function_name open_paren function_args? close_paren; # TODO filter/over
function_name = name; # TODO
function_args =
  | (DISTINCT? expr+comma)=args
  | star;
value =
  | number
  | string;

tokens =
  | less_than
  | greater_than
  | less_than_or_equal
  | greater_than_or_equal
  | not_less_than
  | not_greater_than
  | equal
  | double_equal
  | not_equal
  | plus
  | minus
  | star
  | forward_slash
  | dot
  | percent
  | bitwise_and
  | bitwise_or
  | bitwise_not
  | string_concat
  | shift_left
  | shift_right
;
